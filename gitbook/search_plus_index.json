{"./":{"url":"./","title":"0、什么是设计模式","keywords":"","body":"设计模式 什么是设计模式? 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 设计模式之间的关系 其他 源代码见Github gitbook源代码见Github Java使用了Lombok生成getter、setter等 单元测试使用的Spock 关于Groovy "},"principle.html":{"url":"principle.html","title":"1、设计模式六大原则","keywords":"","body":"设计模式的六大原则 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 "},"content/creational/":{"url":"content/creational/","title":"2、创建型模式","keywords":"","body":"创建型模式 创建模式是对类的实例化过程的抽象化。在一些系统里，可能需要动态的决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。创建模式描述了怎么构造和封装这些动态的决定。创建模式分为类的创建模式和对象的创建模式两种。 类的创建模式 类的创建模式使用继承关系，把类的创建延迟到子类，从而封装了客户端将得到哪些具体类的信息，并且影藏了这些类的实例是如何被创建和放在一起的。 对象的创建模式 对象的创建模式描述的是把对象的创建过程动态地委派给另外一个对象，从而动态地决定客户端讲得到哪些具体的类的实例，以及这些类的实例是如何被创建和组合在一起的。 创建型模式包括：单例、原型、抽象工厂、工厂方法、构造器共5种模式。 "},"content/creational/singleton.html":{"url":"content/creational/singleton.html","title":"2.1、单例模式","keywords":"","body":"单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 JDK中的使用 java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 代码实现 懒汉式实例在第一次使用的时候初始化 public class LazySingleton { private static LazySingleton instance; private LazySingleton(){ } public static synchronized LazySingleton getInstance(){ if(null == instance){ instance = new LazySingleton(); } return instance; } } 双重锁实现懒汉式在多线程情况下会失效 由此进化而来 public class DoubleLockSingleton { private static volatile DoubleLockSingleton instance; private DoubleLockSingleton(){ } public static DoubleLockSingleton getInstance(){ if(null == instance){ synchronized (DoubleLockSingleton.class){ if(null == instance){ instance = new DoubleLockSingleton(); } } } return instance; } } 饿汉式实例在类加载的时候初始化 public class HungrySingleton { private HungrySingleton(){ } public static HungrySingleton getInstance(){ return SingletonHolder.INSTANCE; } private static class SingletonHolder{ private static final HungrySingleton INSTANCE = new HungrySingleton(); } } 枚举实现目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次public enum EnumSingleton { INSTANCE } 单元测试 以DoubleLockSingleton为例 class DoubleLockSingletonSpec extends Specification{ def \"is DoubleLockSingleton singleton\"(){ given: def instance = DoubleLockSingleton.getInstance() def anotherInstance = DoubleLockSingleton.getInstance() expect: instance != null anotherInstance != null instance == anotherInstance instance.is(anotherInstance) } } "},"content/creational/prototype.html":{"url":"content/creational/prototype.html","title":"2.2、原型模式","keywords":"","body":"原型模式 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 JDK中的使用 java.lang.Cloneable java.lang.Object#clone() 代码实现 @Data public class CopyType implements Serializable { private String type; } 浅拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅拷贝所考虑的对象，而不拷贝它所引用的对象。@Data public class ShallowCopy implements Cloneable { private String name; private CopyType copyType; public Object clone(){ try { return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } 深拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被拷贝过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要拷贝的对象所引用的对象都拷贝了一遍。 @Data public class DeepCopy implements Serializable { private String name; private CopyType copyType; public Object clone(){ try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(this); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); return objectInputStream.readObject(); } catch (IOException | ClassNotFoundException e) { return null; } } } 单元测试 class ShallowCopySpec extends Specification { def \"is same by shallow copy\"(){ given: def source = new ShallowCopy( name: \"Jack\", copyType: new CopyType(type: \"shallow\") ) def copy = (ShallowCopy) source.clone() expect: copy != null copy.name != null copy.copyType != null copy.name == source.name copy.name.is(source.name) copy.copyType.type == source.copyType.type copy.copyType == source.copyType copy.copyType.is(source.copyType) !source.is(copy) when: copy.name = \"Jack Chen\" copy.copyType.type = \"just shallow\" then: source.name != copy.name !source.name.is(copy.name) source.copyType.type == copy.copyType.type source.copyType == copy.copyType source.copyType.is(copy.copyType) !source.is(copy) } } class DeepCopySpec extends Specification { def \"is same by deep copy\"(){ given: def source = new DeepCopy( name: \"Jack\", copyType: new CopyType(type: \"deep\") ) def copy = (DeepCopy) source.clone() expect: copy != null copy.name != null copy.copyType != null copy.name == source.name copy.copyType.type == source.copyType.type !copy.copyType.is(source.copyType) !copy.is(source) when: copy.name = \"Jack Chen\" copy.copyType.type = \"just deep\" then: source.name != copy.name source.copyType.type != copy.copyType.type !source.copyType.is(copy.copyType) !source.is(copy) } } "},"content/creational/abstract_factory.html":{"url":"content/creational/abstract_factory.html","title":"2.3、抽象工厂模式","keywords":"","body":"抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。创建新对象的方法，但是返回的是接口或者抽象类。 JDK中的使用 java.util.ResourceBundle#getBundle(java.lang.String) java.sql.Connection#createStatement() java.util.Calendar#getInstance() 代码实现 电视有很多品牌，每个品牌加工厂可以生产不同尺寸的电视，抽象工厂确定有多少种尺寸的电视，不同品牌的工厂可以生产不同品牌的电视 public interface Tv { String getName(); } 假设工厂只能生产21和50英寸的电视 以海尔为例 public interface TvFactory { Tv create21InchTv(); Tv create50InchTv(); } public class Haier21InchTv implements Tv { @Override public String getName() { return \"Haier 21 inch\"; } } public class Haier50InchTv implements Tv { @Override public String getName() { return \"Haier 50 inch\"; } } 如下分别为海尔和索尼的电视工厂 public class HaierTvFactory implements TvFactory { @Override public Tv create21InchTv() { return new Haier21InchTv(); } @Override public Tv create50InchTv() { return new Haier50InchTv(); } } public class SonyTvFactory implements TvFactory { @Override public Tv create21InchTv() { return new Sony21InchTv(); } @Override public Tv create50InchTv() { return new Sony50InchTv(); } } 单元测试 class HaierTvFactorySpec extends Specification { def \"create 21 inch haier tv\"(){ given: def factory = new HaierTvFactory() def tv = factory.create21InchTv() expect: tv != null tv instanceof Haier21InchTv } def \"create 50 inch haier tv\"(){ given: def factory = new HaierTvFactory() def tv = factory.create50InchTv() expect: tv != null tv instanceof Haier50InchTv } } "},"content/creational/factory_method.html":{"url":"content/creational/factory_method.html","title":"2.4、工厂方法模式","keywords":"","body":"工厂方法模式 定义一个用于创建对象的接口，需要指定创建对象具体类。Factory Method使一个类的实例化延迟到其子类，返回具体对象的方法。 JDK中的使用 java.lang.Integer#valueOf(java.lang.String) java.lang.Class#forName(java.lang.String) java.lang.reflect.Constructor#newInstance(java.lang.Object...) java.lang.reflect.Proxy#newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler) 代码实现 有一个生产车的工厂，在你需要什么车的时候生产什么车，与抽象工厂方法的区别就是在使用工厂的时候需要知道具体类 public class CarFactory { public Car create(Class clazz){ try { return clazz.newInstance(); } catch (InstantiationException | IllegalAccessException e) { return null; } } } 车的种类可以水平扩展，工厂不需要变化 public interface Car { String getName(); } public class BmwCar implements Car { @Override public String getName() { return \"Bmw\"; } } public class BenzCar implements Car { @Override public String getName() { return \"Benz\"; } } public class AudiCar implements Car{ @Override public String getName() { return \"Audi\"; } } 单元测试 class CarFactorySpec extends Specification { def create(){ given: def carFactory = new CarFactory() def benz = carFactory.create(BenzCar.class) def bmw = carFactory.create(BmwCar.class) def audi = carFactory.create(AudiCar.class) expect: benz != null bmw != null audi != null benz instanceof BenzCar bmw instanceof BmwCar audi instanceof AudiCar benz.getName() == \"Benz\" bmw.getName() == \"Bmw\" audi.getName() == \"Audi\" } } "},"content/creational/builder.html":{"url":"content/creational/builder.html","title":"2.5、构造器模式","keywords":"","body":"构造器模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 遇到多个构造器参数时要考虑用构建器                     ———— 自Effective Java书中第二条 JDK中的使用 java.lang.StringBuilder#append(boolean) java.nio.ByteBuffer#put(byte) 代码实现 使用Lombok中的@Builder可以快速实现构造器 @Data public class StudentVo implements Serializable { private String no; private String name; private String sex; private Integer age; public static StudentBuilder builder(){ return new StudentBuilder(); } public static class StudentBuilder { private String no; private String name; private String sex; private Integer age; public StudentBuilder no(String no){ this.no = no; return this; } public StudentBuilder name(String name){ this.name = name; return this; } public StudentBuilder sex(String sex){ this.sex = sex; return this; } public StudentBuilder age(Integer age){ this.age = age; return this; } public StudentVo build(){ StudentVo studentVo = new StudentVo(); studentVo.setName(this.name); studentVo.setSex(this.sex); studentVo.setAge(this.age); studentVo.setNo(this.no); return studentVo; } } } 单元测试 class StudentVoSpec extends Specification { def build() { when: def student = StudentVo.builder() .name(\"Jack\") .build() then: student != null student.name == \"Jack\" student.sex == null student.age == null student.no == null when: student = StudentVo.builder() .name(\"zhangsan\") .age(10) .sex(\"male\") .build() then: student != null student.name == \"zhangsan\" student.age == 10 student.sex == \"male\" student.no == null } } "},"content/structural/":{"url":"content/structural/","title":"3、结构型模式","keywords":"","body":"结构型模式 结构模式描述如何将类或对象结合在一起形成更大的结构，结构模式也包括类的结构模式和对象的结构模式。 类的结构模式 类的结构模式使用继承把类、接口等组合在一起，以形成更大的结构。当一个类从父类继承并实现某接口时，这个新的类就把父类的结构和接口的结构结合起来。类的结构模式是静态的，一个类的结构模式的经典列子就是适配器模式。 对象的结构模式 对象的结构模式描述怎么把各种不同的类型的对象组合在一起，以实现新的功能的方法。对象的结构模式是动态的。 结构型模式包括：组合、外观、适配器、桥接、装饰、享元、代理共7种模式。 "},"content/structural/composite.html":{"url":"content/structural/composite.html","title":"3.1、组合模式","keywords":"","body":"组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。 JDK中的使用 java.util.Map#putAll(java.util.Map) java.util.List#addAll(java.util.Collection) java.util.Set#addAll(java.util.Collection) 代码实现 实现一个LinkedList class Node { protected Node previous; protected T data; protected Node next; public Node(Node previous, T data, Node next){ this.previous = previous; this.data = data; this.next = next; } } public class LinkedList { private Node head; private Node tail; private int size = 0; public boolean add(T data) { final Node last = this.tail; final Node current = new Node<>(last, data, null); this.tail = current; if (this.head == null) { this.head = current; } else { last.next = current; } this.size++; return true; } public T get(int index){ if(index = this.size){ throw new IndexOutOfBoundsException(); } Node node = head; for(int i = 0; i i = this.head; i != null; i = i.next) { if ((data == null && i.data == null) || (data != null && data.equals(i.data))) { final Node previous = i.previous; final Node next = i.next; if(previous == null){ this.head = next; }else{ previous.next = next; i.previous = null; } if(next == null){ this.tail = previous; }else{ next.previous = previous; i.next = null; } i.data = null; this.size --; return true; } } return false; } public int size() { return this.size; } public boolean isEmpty(){ return this.size == 0; } } 单元测试 class LinkedListSpec extends Specification { def \"linked list\"() { given: def list = new LinkedList() expect: list != null list.size() == 0 list.isEmpty() when: list.add(1) then: 1 == list.size() 1 == list.get(0) when: list.add(2) then: 2 == list.size() 2 == list.get(1) when: list.add(null) then: 3 == list.size() null == list.get(2) when: def remove = list.remove(1) then: remove 2 == list.size() when: remove = list.remove(332) then: !remove 2 == list.size() when: remove = list.remove(null) then: remove 1 == list.size() when: remove = list.remove(2) then: remove 0 == list.size() list.isEmpty() } } "},"content/structural/facade.html":{"url":"content/structural/facade.html","title":"3.2、外观模式","keywords":"","body":"外观模式 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 JDK中的使用 javax.faces.context.FacesContext 日志log4j等 常见于controller、service、dao，在controller直接与service交互，service为高层接口,dao为子系统。 代码实现 用户发起一笔交易，余额减少，积分增加 @Data @Builder public class Trade { private BigInteger userId; private BigDecimal points; private BigDecimal cash; private BigDecimal consumeCash; private BigDecimal awardPoints; } public class CashDao { // 现金/余额记账 public void accountCash(Trade trade){ BigDecimal currentCash = trade.getCash(); BigDecimal consumeCash = trade.getConsumeCash(); trade.setCash(currentCash.subtract(consumeCash)); } } public class PointDao { // 积分记账 public void accountPoint(Trade trade){ BigDecimal currentPoints = trade.getPoints(); BigDecimal awardPoints = trade.getAwardPoints(); trade.setPoints(currentPoints.add(awardPoints)); } } public class TradeService { // Spring inject private CashDao cashDao = new CashDao(); private PointDao pointDao = new PointDao(); // 用户使用现金消费 积分增加 public void consume(Trade trade){ this.cashDao.accountCash(trade); this.pointDao.accountPoint(trade); } } 对于客户端来说只知道TradeService却感知不到CashDao、PointDao 单元测试 class TradeServiceSpec extends Specification { def \"facade\"() { given: def trade = Trade.builder() .userId(new BigInteger(\"1\")) .cash(new BigDecimal(\"20\")) .points(new BigDecimal(\"100\")) .consumeCash(new BigDecimal(\"10\")) .awardPoints(new BigDecimal(\"100\")) .build() def tradeService = new TradeService() when: tradeService.consume(trade) then: trade.getCash() == new BigDecimal(\"10\") trade.getPoints() == new BigDecimal(\"200\") } def \"not use facade\"(){ given: def trade = Trade.builder() .userId(new BigInteger(\"1\")) .cash(new BigDecimal(\"20\")) .points(new BigDecimal(\"100\")) .consumeCash(new BigDecimal(\"10\")) .awardPoints(new BigDecimal(\"100\")) .build() def cashDao = new CashDao() def pointDao = new PointDao() when: cashDao.accountCash(trade) then: trade.getCash() == new BigDecimal(\"10\") when: pointDao.accountPoint(trade) then: trade.getPoints() == new BigDecimal(\"200\") } } "},"content/structural/adapter.html":{"url":"content/structural/adapter.html","title":"3.3、适配器模式","keywords":"","body":"适配器模式 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。 JDK中的使用 java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() java.io.InputStreamReader#InputStreamReader(java.io.InputStream) java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream) 代码实现 美国使用的三孔插座且需要的电压是110V 中国使用的是两孔插座且且需要电压是220V 三孔插座拿到中国需要转换为两孔插座才能使用 public interface TwoPinSoket { String chargeWithTwoPin(); int voltage(); } public class TwoPinSoketChina implements TwoPinSoket { @Override public String chargeWithTwoPin() { return \"两孔插座\"; } @Override public int voltage() { return 220; } } public interface ThreePinSoket { String chargeWithThreePin(); int voltage(); } public class ThreePinSoketAmerica implements ThreePinSoket { @Override public String chargeWithThreePin() { return \"三孔插座\"; } @Override public int voltage() { return 110; } } 美国插座的适配器 public class AmericaAdapter implements TwoPinSoket { private ThreePinSoket threePinSoket; public AmericaAdapter(ThreePinSoket threePinSoket){ this.threePinSoket = threePinSoket; } @Override public String chargeWithTwoPin() { return this.threePinSoket.chargeWithThreePin(); } @Override public int voltage() { return this.threePinSoket.voltage() * 2; } } 单元测试 class AmericaAdapterSpec extends Specification { def twoPinSoket(){ given: def twoPinSoket = new TwoPinSoketChina() expect: twoPinSoket.chargeWithTwoPin() == \"两孔插座\" twoPinSoket.voltage() == 220 } def threePinSoket(){ given: def threePinSoket = new ThreePinSoketAmerica() expect: threePinSoket.chargeWithThreePin() == \"三孔插座\" threePinSoket.voltage() == 110 } def adapter(){ given: def threePinSoket = new ThreePinSoketAmerica() def twoPinSoket = new AmericaAdapter(threePinSoket) expect: twoPinSoket.chargeWithTwoPin() == \"三孔插座\" twoPinSoket.voltage() == 220 } } "},"content/structural/bridge.html":{"url":"content/structural/bridge.html","title":"3.4、桥接模式","keywords":"","body":"桥接模式 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 JDK中的使用 java.util.logging.Handler java.util.logging.Formatter java.util.Collections#newSetFromMap() jdbc 代码实现 邮件、微信、QQ都可以发送文字、图片、声音消息 当邮件、微信、QQ发送消息时 只有发送消息内容改变 其他不会变 public abstract class Message { protected abstract String getMsg(); } public class Text extends Message { @Override protected String getMsg() { return \"text\"; } } public class Picture extends Message { @Override protected String getMsg() { return \"picture\"; } } public class Voice extends Message { @Override protected String getMsg() { return \"voice\"; } } 消息发送 public abstract class Communicator { Message message; public abstract String send(); public void setMessage(Message message){ this.message = message; } } public class Email extends Communicator { @Override public String send() { return \"email send \" + super.message.getMsg(); } } public class Qicq extends Communicator { @Override public String send() { return \"qicq send \" + super.message.getMsg(); } } public class Wechat extends Communicator { @Override public String send() { return \"wechat send \" + super.message.getMsg(); } } 单元测试 以微信为例 其他两个类似 class WechatSpec extends Specification { @Unroll def \"#result\"() { given: def wechat = new Wechat() wechat.setMessage(message) expect: wechat.send() == result where: message || result new Picture() || \"wechat send picture\" new Text() || \"wechat send text\" new Voice() || \"wechat send voice\" } } "},"content/structural/decorator.html":{"url":"content/structural/decorator.html","title":"3.5、装饰器模式","keywords":"","body":"装饰器模式 装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案 JDK中的使用 java.io.BufferedInputStream#BufferedInputStream(java.io.InputStream) java.io.BufferedOutputStream#BufferedOutputStream(java.io.OutputStream) java.io.DataInputStream#DataInputStream(java.io.InputStream) java.util.Collections.CheckedList java.util.Collections.CheckedSet ava.util.Collections.CheckedMap 代码实现 齐天大圣可以72变 在和杨戬大战中分别变了鸟、鱼、树、寺庙、本身猴子 各个变换之间来回变化 public interface TheGreatestSage { String move(); } public class Monkey implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Monkey() { } public Monkey(TheGreatestSage theGreatestSage) { this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(); if (null != this.theGreatestSage) { sb.append(this.theGreatestSage.move()); sb.append(\" -> \"); } sb.append(\"monkey\"); return sb.toString(); } } public class Bird implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Bird(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"bird\"); return sb.toString(); } } public class Fish implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Fish(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"fish\"); return sb.toString(); } } public class Tree implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Tree(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"tree\"); return sb.toString(); } } public class Temple implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Temple(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"temple\"); return sb.toString(); } } 单元测试 class TheGreatestSageSpec extends Specification { def theGreatestSage() { expect: theGreatestSage.move() == changeProcess where: theGreatestSage || changeProcess new Monkey() || \"monkey\" new Bird(new Monkey()) || \"monkey -> bird\" new Tree(new Fish(new Monkey())) || \"monkey -> fish -> tree\" new Fish(new Bird(new Temple(new Monkey()))) || \"monkey -> temple -> bird -> fish\" new Temple(new Tree(new Bird(new Fish(new Monkey())))) || \"monkey -> fish -> bird -> tree -> temple\" new Monkey(new Tree(new Temple(new Bird(new Fish(new Monkey()))))) || \"monkey -> fish -> bird -> temple -> tree -> monkey\" } } "},"content/structural/flyweight.html":{"url":"content/structural/flyweight.html","title":"3.6、享元模式","keywords":"","body":"享元模式 享元模式以共享的方式高效地支持大量的细粒度对象，包括内部状态和外部状态。内部状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内部状态并可以共享。外部状态是随环境的改变而改变的、不可以共享的。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外部状态不可以影响享元对象的内部状态，它们是相互独立的。 JDK中的使用 java.lang.Integer#valueOf(int) java.lang.Byte#valueOf(byte) Boolean, Byte, Character, Short, Long, BigDecimal 代码实现 绘制不同颜色的不同图形 将已经绘制过的图形保存起来不用再次绘制 public interface Shape { String draw(Color color); } public class ConcreteShape implements Shape { private String shape; public ConcreteShape(String shape) { this.shape = shape; } @Override public String draw(Color color) { StringBuilder sb = new StringBuilder(); sb.append(\"draw a\"); sb.append(\" \"); sb.append(color.getColor()); sb.append(\" \"); sb.append(this.shape); return sb.toString(); } } public class Color { @Getter private String color; public Color(String color){ this.color = color; } } public class FlyweightFactory { private final Map cache = new ConcurrentHashMap<>(); public Shape create(String shape){ if(!this.cache.containsKey(shape)){ synchronized (this.cache){ if(!this.cache.containsKey(shape)){ this.cache.put(shape, new ConcreteShape(shape)); } } } return this.cache.get(shape); } public int size(){ return this.cache.size(); } } 单元测试 class FlyweightFactorySpec extends Specification { def flyweightInnerState() { given: def factory = new FlyweightFactory() when: def circle = factory.create(\"circle\") def circleCopy = factory.create(\"circle\") then: circle != null circleCopy != null circle == circleCopy circle.is(circleCopy) when: def rectangle = factory.create(\"rectangle\") def rectangleCopy = factory.create(\"rectangle\") then: rectangle != null rectangleCopy != null rectangle == rectangleCopy rectangle.is(rectangleCopy) when: def triangle = factory.create(\"triangle\") def triangleCopy = factory.create(\"triangle\") then: triangle != null triangleCopy != null triangle == triangleCopy triangle.is(triangleCopy) expect: factory.size() == 3 } def flyweightOuterState() { given: def factory = new FlyweightFactory() expect: factory.create(shape).draw(new Color(color)) == draw where: shape | color || draw \"circle\" | \"red\" || \"draw a red circle\" \"rectangle\" | \"yellow\" || \"draw a yellow rectangle\" \"triangle\" | \"black\" || \"draw a black triangle\" \"circle\" | \"black\" || \"draw a black circle\" } } "},"content/behavioural/":{"url":"content/behavioural/","title":"4、行为型模式","keywords":"","body":"行为型模式 行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间相互作用的。 类的行为模式 类的行为模式使用继承关系在几个类之间分配行为。 对象的行为模式 对象的行为模式是使用对象聚合类分配行为的。 行为型模式包括：责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模版方法、访问者共11中模式。 "}}