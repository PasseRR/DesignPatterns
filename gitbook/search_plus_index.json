{"./":{"url":"./","title":"0、什么是设计模式","keywords":"","body":"设计模式 什么是设计模式? 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 设计模式之间的关系 其他 源代码见Github gitbook源代码见Github Java使用了Lombok生成getter、setter等 单元测试使用的Spock 关于Groovy "},"principle.html":{"url":"principle.html","title":"1、设计模式六大原则","keywords":"","body":"设计模式的六大原则 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 "},"content/creational/":{"url":"content/creational/","title":"2、创建型模式","keywords":"","body":"创建型模式 创建模式是对类的实例化过程的抽象化。在一些系统里，可能需要动态的决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。创建模式描述了怎么构造和封装这些动态的决定。创建模式分为类的创建模式和对象的创建模式两种。 类的创建模式 类的创建模式使用继承关系，把类的创建延迟到子类，从而封装了客户端将得到哪些具体类的信息，并且影藏了这些类的实例是如何被创建和放在一起的。 对象的创建模式 对象的创建模式描述的是把对象的创建过程动态地委派给另外一个对象，从而动态地决定客户端讲得到哪些具体的类的实例，以及这些类的实例是如何被创建和组合在一起的。 创建型模式包括：单例、原型、抽象工厂、工厂方法、构造器共5种模式。 "},"content/creational/singleton.html":{"url":"content/creational/singleton.html","title":"2.1、单例模式","keywords":"","body":"单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 JDK中的使用 java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 代码实现 懒汉式实例在第一次使用的时候初始化 public class LazySingleton { private static LazySingleton instance; private LazySingleton(){ } public static synchronized LazySingleton getInstance(){ if(null == instance){ instance = new LazySingleton(); } return instance; } } 双重锁实现懒汉式在多线程情况下会失效 由此进化而来 public class DoubleLockSingleton { private static volatile DoubleLockSingleton instance; private DoubleLockSingleton(){ } public static DoubleLockSingleton getInstance(){ if(null == instance){ synchronized (DoubleLockSingleton.class){ if(null == instance){ instance = new DoubleLockSingleton(); } } } return instance; } } 饿汉式实例在类加载的时候初始化 public class HungrySingleton { private HungrySingleton(){ } public static HungrySingleton getInstance(){ return SingletonHolder.INSTANCE; } private static class SingletonHolder{ private static final HungrySingleton INSTANCE = new HungrySingleton(); } } 枚举实现目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次public enum EnumSingleton { INSTANCE } 单元测试 以DoubleLockSingleton为例 class DoubleLockSingletonSpec extends Specification{ def \"is DoubleLockSingleton singleton\"(){ given: def instance = DoubleLockSingleton.getInstance() def anotherInstance = DoubleLockSingleton.getInstance() expect: instance != null anotherInstance != null instance == anotherInstance instance.is(anotherInstance) } } "},"content/creational/prototype.html":{"url":"content/creational/prototype.html","title":"2.2、原型模式","keywords":"","body":"原型模式 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 JDK中的使用 java.lang.Cloneable java.lang.Object#clone() 代码实现 @Data public class CopyType implements Serializable { private String type; } 浅拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅拷贝所考虑的对象，而不拷贝它所引用的对象。@Data public class ShallowCopy implements Cloneable { private String name; private CopyType copyType; public Object clone(){ try { return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } 深拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被拷贝过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要拷贝的对象所引用的对象都拷贝了一遍。 @Data public class DeepCopy implements Serializable { private String name; private CopyType copyType; public Object clone(){ try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(this); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); return objectInputStream.readObject(); } catch (IOException | ClassNotFoundException e) { return null; } } } 单元测试 class ShallowCopySpec extends Specification { def \"is same by shallow copy\"(){ given: def source = new ShallowCopy( name: \"Jack\", copyType: new CopyType(type: \"shallow\") ) def copy = (ShallowCopy) source.clone() expect: copy != null copy.name != null copy.copyType != null copy.name == source.name copy.name.is(source.name) copy.copyType.type == source.copyType.type copy.copyType == source.copyType copy.copyType.is(source.copyType) !source.is(copy) when: copy.name = \"Jack Chen\" copy.copyType.type = \"just shallow\" then: source.name != copy.name !source.name.is(copy.name) source.copyType.type == copy.copyType.type source.copyType == copy.copyType source.copyType.is(copy.copyType) !source.is(copy) } } class DeepCopySpec extends Specification { def \"is same by deep copy\"(){ given: def source = new DeepCopy( name: \"Jack\", copyType: new CopyType(type: \"deep\") ) def copy = (DeepCopy) source.clone() expect: copy != null copy.name != null copy.copyType != null copy.name == source.name copy.copyType.type == source.copyType.type !copy.copyType.is(source.copyType) !copy.is(source) when: copy.name = \"Jack Chen\" copy.copyType.type = \"just deep\" then: source.name != copy.name source.copyType.type != copy.copyType.type !source.copyType.is(copy.copyType) !source.is(copy) } } "},"content/creational/abstract_factory.html":{"url":"content/creational/abstract_factory.html","title":"2.3、抽象工厂模式","keywords":"","body":"抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。创建新对象的方法，但是返回的是接口或者抽象类。 JDK中的使用 java.util.ResourceBundle#getBundle(java.lang.String) java.sql.Connection#createStatement() java.util.Calendar#getInstance() 代码实现 电视有很多品牌，每个品牌加工厂可以生产不同尺寸的电视，抽象工厂确定有多少种尺寸的电视，不同品牌的工厂可以生产不同品牌的电视 public interface Tv { String getName(); } 假设工厂只能生产21和50英寸的电视 以海尔为例 public interface TvFactory { Tv create21InchTv(); Tv create50InchTv(); } public class Haier21InchTv implements Tv { @Override public String getName() { return \"Haier 21 inch\"; } } public class Haier50InchTv implements Tv { @Override public String getName() { return \"Haier 50 inch\"; } } 如下分别为海尔和索尼的电视工厂 public class HaierTvFactory implements TvFactory { @Override public Tv create21InchTv() { return new Haier21InchTv(); } @Override public Tv create50InchTv() { return new Haier50InchTv(); } } public class SonyTvFactory implements TvFactory { @Override public Tv create21InchTv() { return new Sony21InchTv(); } @Override public Tv create50InchTv() { return new Sony50InchTv(); } } 单元测试 class HaierTvFactorySpec extends Specification { def \"create 21 inch haier tv\"(){ given: def factory = new HaierTvFactory() def tv = factory.create21InchTv() expect: tv != null tv instanceof Haier21InchTv } def \"create 50 inch haier tv\"(){ given: def factory = new HaierTvFactory() def tv = factory.create50InchTv() expect: tv != null tv instanceof Haier50InchTv } } "},"content/creational/factory_method.html":{"url":"content/creational/factory_method.html","title":"2.4、工厂方法模式","keywords":"","body":"工厂方法模式 定义一个用于创建对象的接口，需要指定创建对象具体类。Factory Method使一个类的实例化延迟到其子类，返回具体对象的方法。 JDK中的使用 java.lang.Integer#valueOf(java.lang.String) java.lang.Class#forName(java.lang.String) java.lang.reflect.Constructor#newInstance(java.lang.Object...) java.lang.reflect.Proxy#newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler) 代码实现 有一个生产车的工厂，在你需要什么车的时候生产什么车，与抽象工厂方法的区别就是在使用工厂的时候需要知道具体类 public class CarFactory { public Car create(Class clazz){ try { return clazz.newInstance(); } catch (InstantiationException | IllegalAccessException e) { return null; } } } 车的种类可以水平扩展，工厂不需要变化 public interface Car { String getName(); } public class BmwCar implements Car { @Override public String getName() { return \"Bmw\"; } } public class BenzCar implements Car { @Override public String getName() { return \"Benz\"; } } public class AudiCar implements Car{ @Override public String getName() { return \"Audi\"; } } 单元测试 class CarFactorySpec extends Specification { def create(){ given: def carFactory = new CarFactory() def benz = carFactory.create(BenzCar.class) def bmw = carFactory.create(BmwCar.class) def audi = carFactory.create(AudiCar.class) expect: benz != null bmw != null audi != null benz instanceof BenzCar bmw instanceof BmwCar audi instanceof AudiCar benz.getName() == \"Benz\" bmw.getName() == \"Bmw\" audi.getName() == \"Audi\" } } "},"content/creational/builder.html":{"url":"content/creational/builder.html","title":"2.5、构造器模式","keywords":"","body":"构造器模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 遇到多个构造器参数时要考虑用构建器                     ———— 自Effective Java书中第二条 JDK中的使用 java.lang.StringBuilder#append(boolean) java.nio.ByteBuffer#put(byte) 代码实现 使用Lombok中的@Builder可以快速实现构造器 @Data public class StudentVo implements Serializable { private String no; private String name; private String sex; private Integer age; public static StudentBuilder builder(){ return new StudentBuilder(); } public static class StudentBuilder { private String no; private String name; private String sex; private Integer age; public StudentBuilder no(String no){ this.no = no; return this; } public StudentBuilder name(String name){ this.name = name; return this; } public StudentBuilder sex(String sex){ this.sex = sex; return this; } public StudentBuilder age(Integer age){ this.age = age; return this; } public StudentVo build(){ StudentVo studentVo = new StudentVo(); studentVo.setName(this.name); studentVo.setSex(this.sex); studentVo.setAge(this.age); studentVo.setNo(this.no); return studentVo; } } } 单元测试 class StudentVoSpec extends Specification { def build() { when: def student = StudentVo.builder() .name(\"Jack\") .build() then: student != null student.name == \"Jack\" student.sex == null student.age == null student.no == null when: student = StudentVo.builder() .name(\"zhangsan\") .age(10) .sex(\"male\") .build() then: student != null student.name == \"zhangsan\" student.age == 10 student.sex == \"male\" student.no == null } } "},"content/structural/":{"url":"content/structural/","title":"3、结构型模式","keywords":"","body":"结构型模式 结构模式描述如何将类或对象结合在一起形成更大的结构，结构模式也包括类的结构模式和对象的结构模式。 类的结构模式 类的结构模式使用继承把类、接口等组合在一起，以形成更大的结构。当一个类从父类继承并实现某接口时，这个新的类就把父类的结构和接口的结构结合起来。类的结构模式是静态的，一个类的结构模式的经典列子就是适配器模式。 对象的结构模式 对象的结构模式描述怎么把各种不同的类型的对象组合在一起，以实现新的功能的方法。对象的结构模式是动态的。 结构型模式包括：组合、外观、适配器、桥接、装饰、享元、代理共7种模式。 "},"content/structural/composite.html":{"url":"content/structural/composite.html","title":"3.1、组合模式","keywords":"","body":"组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。 JDK中的使用 java.util.Map#putAll(java.util.Map) java.util.List#addAll(java.util.Collection) java.util.Set#addAll(java.util.Collection) 代码实现 实现一个LinkedList class Node { protected Node previous; protected T data; protected Node next; public Node(Node previous, T data, Node next){ this.previous = previous; this.data = data; this.next = next; } } public class LinkedList { private Node head; private Node tail; private int size = 0; public boolean add(T data) { final Node last = this.tail; final Node current = new Node<>(last, data, null); this.tail = current; if (this.head == null) { this.head = current; } else { last.next = current; } this.size++; return true; } public T get(int index){ if(index = this.size){ throw new IndexOutOfBoundsException(); } Node node = head; for(int i = 0; i i = this.head; i != null; i = i.next) { if ((data == null && i.data == null) || (data != null && data.equals(i.data))) { final Node previous = i.previous; final Node next = i.next; if(previous == null){ this.head = next; }else{ previous.next = next; i.previous = null; } if(next == null){ this.tail = previous; }else{ next.previous = previous; i.next = null; } i.data = null; this.size --; return true; } } return false; } public int size() { return this.size; } public boolean isEmpty(){ return this.size == 0; } } 单元测试 class LinkedListSpec extends Specification { def \"linked list\"() { given: def list = new LinkedList() expect: list != null list.size() == 0 list.isEmpty() when: list.add(1) then: 1 == list.size() 1 == list.get(0) when: list.add(2) then: 2 == list.size() 2 == list.get(1) when: list.add(null) then: 3 == list.size() null == list.get(2) when: def remove = list.remove(1) then: remove 2 == list.size() when: remove = list.remove(332) then: !remove 2 == list.size() when: remove = list.remove(null) then: remove 1 == list.size() when: remove = list.remove(2) then: remove 0 == list.size() list.isEmpty() } } "},"content/behavioural/":{"url":"content/behavioural/","title":"4、行为型模式","keywords":"","body":"行为型模式 行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间相互作用的。 类的行为模式 类的行为模式使用继承关系在几个类之间分配行为。 对象的行为模式 对象的行为模式是使用对象聚合类分配行为的。 行为型模式包括：责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模版方法、访问者共11中模式。 "}}