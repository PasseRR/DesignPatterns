{"./":{"url":"./","title":"0、什么是设计模式","keywords":"","body":"设计模式 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 "},"principle.html":{"url":"principle.html","title":"1、设计模式六大原则","keywords":"","body":"设计模式的六大原则 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 "},"content/creational/":{"url":"content/creational/","title":"2、创建型模式","keywords":"","body":"创建型模式 创建模式是对类的实例化过程的抽象化。在一些系统里，可能需要动态的决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。创建模式描述了怎么构造和封装这些动态的决定。创建模式分为类的创建模式和对象的创建模式两种。 类的创建模式 类的创建模式使用继承关系，把类的创建延迟到子类，从而封装了客户端将得到哪些具体类的信息，并且影藏了这些类的实例是如何被创建和放在一起的。 对象的创建模式 对象的创建模式描述的是把对象的创建过程动态地委派给另外一个对象，从而动态地决定客户端讲得到哪些具体的类的实例，以及这些类的实例是如何被创建和组合在一起的。 创建型模式包括：抽象工厂、工厂方法、建造者、原型、单例共5种模式。 "},"content/creational/singleton.html":{"url":"content/creational/singleton.html","title":"2.1、单例模式","keywords":"","body":"单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 JDK中的使用 java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 代码实现 懒汉式实例在第一次使用的时候初始化 public class LazySingleton { private static LazySingleton instance; private LazySingleton(){ } public static synchronized LazySingleton getInstance(){ if(null == instance){ instance = new LazySingleton(); } return instance; } } 双重锁实现懒汉式在多线程情况下会失效 由此进化而来 public class DoubleLockSingleton { private static volatile DoubleLockSingleton instance; private DoubleLockSingleton(){ } public static DoubleLockSingleton getInstance(){ if(null == instance){ synchronized (DoubleLockSingleton.class){ if(null == instance){ instance = new DoubleLockSingleton(); } } } return instance; } } 饿汉式实例在类加载的时候初始化 public class HungrySingleton { private HungrySingleton(){ } public static HungrySingleton getInstance(){ return SingletonHolder.INSTANCE; } private static class SingletonHolder{ private static final HungrySingleton INSTANCE = new HungrySingleton(); } } 枚举实现目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次public enum EnumSingleton { INSTANCE } "},"content/creational/prototype.html":{"url":"content/creational/prototype.html","title":"2.2、原型模式","keywords":"","body":"原型模式 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 JDK中的使用 java.lang.Cloneable java.lang.Object#clone() 代码实现 @Data public class CopyType implements Serializable { private String type; } 浅拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅拷贝所考虑的对象，而不拷贝它所引用的对象。@Data public class ShallowCopy implements Cloneable { private String name; private CopyType copyType; public Object clone(){ try { return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } 深拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被拷贝过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要拷贝的对象所引用的对象都拷贝了一遍。 @Data public class DeepCopy implements Serializable { private String name; private CopyType copyType; public Object clone(){ try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(this); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); return objectInputStream.readObject(); } catch (IOException | ClassNotFoundException e) { return null; } } } "},"content/creational/abstract_factory.html":{"url":"content/creational/abstract_factory.html","title":"2.3、抽象工厂模式","keywords":"","body":"抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。创建新对象的方法，但是返回的是接口或者抽象类。 JDK中的使用 java.util.ResourceBundle#getBundle(java.lang.String) java.sql.Connection#createStatement() java.util.Calendar#getInstance() 实现 "},"content/structural/":{"url":"content/structural/","title":"3、结构型模式","keywords":"","body":"结构型模式 结构模式描述如何将类或对象结合在一起形成更大的结构，结构模式也包括类的结构模式和对象的结构模式。 类的结构模式 类的结构模式使用继承把类、接口等组合在一起，以形成更大的结构。当一个类从父类继承并实现某接口时，这个新的类就把父类的结构和接口的结构结合起来。类的结构模式是静态的，一个类的结构模式的经典列子就是适配器模式。 对象的结构模式 对象的结构模式描述怎么把各种不同的类型的对象组合在一起，以实现新的功能的方法。对象的结构模式是动态的。 结构型模式包括：适配器、桥接、组合、装饰、外观、享元、代理共7种模式。 "},"content/behavioural/":{"url":"content/behavioural/","title":"4、行为型模式","keywords":"","body":"行为型模式 行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间相互作用的。 类的行为模式 类的行为模式使用继承关系在几个类之间分配行为。 对象的行为模式 对象的行为模式是使用对象聚合类分配行为的。 行为型模式包括：责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模版方法、访问者共11中模式。 "}}