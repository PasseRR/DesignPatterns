{"./":{"url":"./","title":"0、关于设计模式","keywords":"","body":"设计模式 什么是设计模式? 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。 设计模式之间的关系 设计模式的六大原则 开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle） 为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。 其他 源代码见Github gitbook源代码见Github Java使用了Lombok生成getter、setter等 单元测试使用的Spock 关于Groovy "},"content/creational/":{"url":"content/creational/","title":"1、创建型模式","keywords":"","body":"创建型模式 创建模式是对类的实例化过程的抽象化。在一些系统里，可能需要动态的决定怎样创建对象，创建哪些对象，以及如何组合和表示这些对象。创建模式描述了怎么构造和封装这些动态的决定。创建模式分为类的创建模式和对象的创建模式两种。 类的创建模式 类的创建模式使用继承关系，把类的创建延迟到子类，从而封装了客户端将得到哪些具体类的信息，并且影藏了这些类的实例是如何被创建和放在一起的。 对象的创建模式 对象的创建模式描述的是把对象的创建过程动态地委派给另外一个对象，从而动态地决定客户端讲得到哪些具体的类的实例，以及这些类的实例是如何被创建和组合在一起的。 创建型模式包括：单例、原型、抽象工厂、工厂方法、构造器共5种模式。 "},"content/creational/singleton.html":{"url":"content/creational/singleton.html","title":"1.1、单例模式","keywords":"","body":"单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 JDK中的使用 java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 代码实现 懒汉式实例在第一次使用的时候初始化 public class LazySingleton { private static LazySingleton instance; private LazySingleton(){ } public static synchronized LazySingleton getInstance(){ if(null == instance){ instance = new LazySingleton(); } return instance; } } 双重锁实现懒汉式在多线程情况下会失效 由此进化而来 public class DoubleLockSingleton { private static volatile DoubleLockSingleton instance; private DoubleLockSingleton(){ } public static DoubleLockSingleton getInstance(){ if(null == instance){ synchronized (DoubleLockSingleton.class){ if(null == instance){ instance = new DoubleLockSingleton(); } } } return instance; } } 饿汉式实例在类加载的时候初始化 public class HungrySingleton { private HungrySingleton(){ } public static HungrySingleton getInstance(){ return SingletonHolder.INSTANCE; } private static class SingletonHolder{ private static final HungrySingleton INSTANCE = new HungrySingleton(); } } 枚举实现目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次public enum EnumSingleton { INSTANCE } 单元测试 以DoubleLockSingleton为例 class DoubleLockSingletonSpec extends Specification{ def \"is DoubleLockSingleton singleton\"(){ given: def instance = DoubleLockSingleton.getInstance() def anotherInstance = DoubleLockSingleton.getInstance() expect: instance != null anotherInstance != null instance == anotherInstance instance.is(anotherInstance) } } "},"content/creational/prototype.html":{"url":"content/creational/prototype.html","title":"1.2、原型模式","keywords":"","body":"原型模式 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。 JDK中的使用 java.lang.Cloneable java.lang.Object#clone() 代码实现 @Data public class CopyType implements Serializable { private String type; } 浅拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅拷贝所考虑的对象，而不拷贝它所引用的对象。@Data public class ShallowCopy implements Cloneable { private String name; private CopyType copyType; public Object clone(){ try { return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } 深拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被拷贝过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要拷贝的对象所引用的对象都拷贝了一遍。 @Data public class DeepCopy implements Serializable { private String name; private CopyType copyType; public Object clone(){ try { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(this); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); return objectInputStream.readObject(); } catch (IOException | ClassNotFoundException e) { return null; } } } 单元测试 class ShallowCopySpec extends Specification { def \"is same by shallow copy\"(){ given: def source = new ShallowCopy( name: \"Jack\", copyType: new CopyType(type: \"shallow\") ) def copy = (ShallowCopy) source.clone() expect: copy != null copy.name != null copy.copyType != null copy.name == source.name copy.name.is(source.name) copy.copyType.type == source.copyType.type copy.copyType == source.copyType copy.copyType.is(source.copyType) !source.is(copy) when: copy.name = \"Jack Chen\" copy.copyType.type = \"just shallow\" then: source.name != copy.name !source.name.is(copy.name) source.copyType.type == copy.copyType.type source.copyType == copy.copyType source.copyType.is(copy.copyType) !source.is(copy) } } class DeepCopySpec extends Specification { def \"is same by deep copy\"(){ given: def source = new DeepCopy( name: \"Jack\", copyType: new CopyType(type: \"deep\") ) def copy = (DeepCopy) source.clone() expect: copy != null copy.name != null copy.copyType != null copy.name == source.name copy.copyType.type == source.copyType.type !copy.copyType.is(source.copyType) !copy.is(source) when: copy.name = \"Jack Chen\" copy.copyType.type = \"just deep\" then: source.name != copy.name source.copyType.type != copy.copyType.type !source.copyType.is(copy.copyType) !source.is(copy) } } "},"content/creational/abstract_factory.html":{"url":"content/creational/abstract_factory.html","title":"1.3、抽象工厂模式","keywords":"","body":"抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。创建新对象的方法，但是返回的是接口或者抽象类。 JDK中的使用 java.util.ResourceBundle#getBundle(java.lang.String) java.sql.Connection#createStatement() java.util.Calendar#getInstance() 代码实现 电视有很多品牌，每个品牌加工厂可以生产不同尺寸的电视，抽象工厂确定有多少种尺寸的电视，不同品牌的工厂可以生产不同品牌的电视 public interface Tv { String getName(); } 假设工厂只能生产21和50英寸的电视 以海尔为例 public interface TvFactory { Tv create21InchTv(); Tv create50InchTv(); } public class Haier21InchTv implements Tv { @Override public String getName() { return \"Haier 21 inch\"; } } public class Haier50InchTv implements Tv { @Override public String getName() { return \"Haier 50 inch\"; } } 如下分别为海尔和索尼的电视工厂 public class HaierTvFactory implements TvFactory { @Override public Tv create21InchTv() { return new Haier21InchTv(); } @Override public Tv create50InchTv() { return new Haier50InchTv(); } } public class SonyTvFactory implements TvFactory { @Override public Tv create21InchTv() { return new Sony21InchTv(); } @Override public Tv create50InchTv() { return new Sony50InchTv(); } } 单元测试 class HaierTvFactorySpec extends Specification { def \"create 21 inch haier tv\"(){ given: def factory = new HaierTvFactory() def tv = factory.create21InchTv() expect: tv != null tv instanceof Haier21InchTv } def \"create 50 inch haier tv\"(){ given: def factory = new HaierTvFactory() def tv = factory.create50InchTv() expect: tv != null tv instanceof Haier50InchTv } } "},"content/creational/factory_method.html":{"url":"content/creational/factory_method.html","title":"1.4、工厂方法模式","keywords":"","body":"工厂方法模式 定义一个用于创建对象的接口，需要指定创建对象具体类。Factory Method使一个类的实例化延迟到其子类，返回具体对象的方法。 JDK中的使用 java.lang.Integer#valueOf(java.lang.String) java.lang.Class#forName(java.lang.String) java.lang.reflect.Constructor#newInstance(java.lang.Object...) java.lang.reflect.Proxy#newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler) 代码实现 有一个生产车的工厂，在你需要什么车的时候生产什么车，与抽象工厂方法的区别就是在使用工厂的时候需要知道具体类 public class CarFactory { public Car create(Class clazz){ try { return clazz.newInstance(); } catch (InstantiationException | IllegalAccessException e) { return null; } } } 车的种类可以水平扩展，工厂不需要变化 public interface Car { String getName(); } public class BmwCar implements Car { @Override public String getName() { return \"Bmw\"; } } public class BenzCar implements Car { @Override public String getName() { return \"Benz\"; } } public class AudiCar implements Car{ @Override public String getName() { return \"Audi\"; } } 单元测试 class CarFactorySpec extends Specification { def create(){ given: def carFactory = new CarFactory() def benz = carFactory.create(BenzCar.class) def bmw = carFactory.create(BmwCar.class) def audi = carFactory.create(AudiCar.class) expect: benz != null bmw != null audi != null benz instanceof BenzCar bmw instanceof BmwCar audi instanceof AudiCar benz.getName() == \"Benz\" bmw.getName() == \"Bmw\" audi.getName() == \"Audi\" } } "},"content/creational/builder.html":{"url":"content/creational/builder.html","title":"1.5、构造器模式","keywords":"","body":"构造器模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 遇到多个构造器参数时要考虑用构建器                     ———— 自Effective Java书中第二条 JDK中的使用 java.lang.StringBuilder#append(boolean) java.nio.ByteBuffer#put(byte) 代码实现 使用Lombok中的@Builder可以快速实现构造器 @Data public class StudentVo implements Serializable { private String no; private String name; private String sex; private Integer age; public static StudentBuilder builder(){ return new StudentBuilder(); } public static class StudentBuilder { private String no; private String name; private String sex; private Integer age; public StudentBuilder no(String no){ this.no = no; return this; } public StudentBuilder name(String name){ this.name = name; return this; } public StudentBuilder sex(String sex){ this.sex = sex; return this; } public StudentBuilder age(Integer age){ this.age = age; return this; } public StudentVo build(){ StudentVo studentVo = new StudentVo(); studentVo.setName(this.name); studentVo.setSex(this.sex); studentVo.setAge(this.age); studentVo.setNo(this.no); return studentVo; } } } 单元测试 class StudentVoSpec extends Specification { def build() { when: def student = StudentVo.builder() .name(\"Jack\") .build() then: student != null student.name == \"Jack\" student.sex == null student.age == null student.no == null when: student = StudentVo.builder() .name(\"zhangsan\") .age(10) .sex(\"male\") .build() then: student != null student.name == \"zhangsan\" student.age == 10 student.sex == \"male\" student.no == null } } "},"content/structural/":{"url":"content/structural/","title":"2、结构型模式","keywords":"","body":"结构型模式 结构模式描述如何将类或对象结合在一起形成更大的结构，结构模式也包括类的结构模式和对象的结构模式。 类的结构模式 类的结构模式使用继承把类、接口等组合在一起，以形成更大的结构。当一个类从父类继承并实现某接口时，这个新的类就把父类的结构和接口的结构结合起来。类的结构模式是静态的，一个类的结构模式的经典列子就是适配器模式。 对象的结构模式 对象的结构模式描述怎么把各种不同的类型的对象组合在一起，以实现新的功能的方法。对象的结构模式是动态的。 结构型模式包括：组合、外观、适配器、桥接、装饰、享元、代理共7种模式。 "},"content/structural/composite.html":{"url":"content/structural/composite.html","title":"2.1、组合模式","keywords":"","body":"组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。 JDK中的使用 java.util.Map#putAll(java.util.Map) java.util.List#addAll(java.util.Collection) java.util.Set#addAll(java.util.Collection) 代码实现 实现一个LinkedList class Node { protected Node previous; protected T data; protected Node next; public Node(Node previous, T data, Node next){ this.previous = previous; this.data = data; this.next = next; } } public class LinkedList { private Node head; private Node tail; private int size = 0; public boolean add(T data) { final Node last = this.tail; final Node current = new Node<>(last, data, null); this.tail = current; if (this.head == null) { this.head = current; } else { last.next = current; } this.size++; return true; } public T get(int index){ if(index = this.size){ throw new IndexOutOfBoundsException(); } Node node = head; for(int i = 0; i i = this.head; i != null; i = i.next) { if ((data == null && i.data == null) || (data != null && data.equals(i.data))) { final Node previous = i.previous; final Node next = i.next; if(previous == null){ this.head = next; }else{ previous.next = next; i.previous = null; } if(next == null){ this.tail = previous; }else{ next.previous = previous; i.next = null; } i.data = null; this.size --; return true; } } return false; } public int size() { return this.size; } public boolean isEmpty(){ return this.size == 0; } } 单元测试 class LinkedListSpec extends Specification { def \"linked list\"() { given: def list = new LinkedList() expect: list != null list.size() == 0 list.isEmpty() when: list.add(1) then: 1 == list.size() 1 == list.get(0) when: list.add(2) then: 2 == list.size() 2 == list.get(1) when: list.add(null) then: 3 == list.size() null == list.get(2) when: def remove = list.remove(1) then: remove 2 == list.size() when: remove = list.remove(332) then: !remove 2 == list.size() when: remove = list.remove(null) then: remove 1 == list.size() when: remove = list.remove(2) then: remove 0 == list.size() list.isEmpty() } } "},"content/structural/facade.html":{"url":"content/structural/facade.html","title":"2.2、外观模式","keywords":"","body":"外观模式 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 JDK中的使用 javax.faces.context.FacesContext 日志log4j等 常见于controller、service、dao，在controller直接与service交互，service为高层接口,dao为子系统。 代码实现 用户发起一笔交易，余额减少，积分增加 @Data @Builder public class Trade { private BigInteger userId; private BigDecimal points; private BigDecimal cash; private BigDecimal consumeCash; private BigDecimal awardPoints; } public class CashDao { // 现金/余额记账 public void accountCash(Trade trade){ BigDecimal currentCash = trade.getCash(); BigDecimal consumeCash = trade.getConsumeCash(); trade.setCash(currentCash.subtract(consumeCash)); } } public class PointDao { // 积分记账 public void accountPoint(Trade trade){ BigDecimal currentPoints = trade.getPoints(); BigDecimal awardPoints = trade.getAwardPoints(); trade.setPoints(currentPoints.add(awardPoints)); } } public class TradeService { // Spring inject private CashDao cashDao = new CashDao(); private PointDao pointDao = new PointDao(); // 用户使用现金消费 积分增加 public void consume(Trade trade){ this.cashDao.accountCash(trade); this.pointDao.accountPoint(trade); } } 对于客户端来说只知道TradeService却感知不到CashDao、PointDao 单元测试 class TradeServiceSpec extends Specification { def \"facade\"() { given: def trade = Trade.builder() .userId(new BigInteger(\"1\")) .cash(new BigDecimal(\"20\")) .points(new BigDecimal(\"100\")) .consumeCash(new BigDecimal(\"10\")) .awardPoints(new BigDecimal(\"100\")) .build() def tradeService = new TradeService() when: tradeService.consume(trade) then: trade.getCash() == new BigDecimal(\"10\") trade.getPoints() == new BigDecimal(\"200\") } def \"not use facade\"(){ given: def trade = Trade.builder() .userId(new BigInteger(\"1\")) .cash(new BigDecimal(\"20\")) .points(new BigDecimal(\"100\")) .consumeCash(new BigDecimal(\"10\")) .awardPoints(new BigDecimal(\"100\")) .build() def cashDao = new CashDao() def pointDao = new PointDao() when: cashDao.accountCash(trade) then: trade.getCash() == new BigDecimal(\"10\") when: pointDao.accountPoint(trade) then: trade.getPoints() == new BigDecimal(\"200\") } } "},"content/structural/adapter.html":{"url":"content/structural/adapter.html","title":"2.3、适配器模式","keywords":"","body":"适配器模式 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。 JDK中的使用 java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() java.io.InputStreamReader#InputStreamReader(java.io.InputStream) java.io.OutputStreamWriter#OutputStreamWriter(java.io.OutputStream) 代码实现 美国使用的三孔插座且需要的电压是110V 中国使用的是两孔插座且且需要电压是220V 三孔插座拿到中国需要转换为两孔插座才能使用 public interface TwoPinSoket { String chargeWithTwoPin(); int voltage(); } public class TwoPinSoketChina implements TwoPinSoket { @Override public String chargeWithTwoPin() { return \"两孔插座\"; } @Override public int voltage() { return 220; } } public interface ThreePinSoket { String chargeWithThreePin(); int voltage(); } public class ThreePinSoketAmerica implements ThreePinSoket { @Override public String chargeWithThreePin() { return \"三孔插座\"; } @Override public int voltage() { return 110; } } 美国插座的适配器 public class AmericaAdapter implements TwoPinSoket { private ThreePinSoket threePinSoket; public AmericaAdapter(ThreePinSoket threePinSoket){ this.threePinSoket = threePinSoket; } @Override public String chargeWithTwoPin() { return this.threePinSoket.chargeWithThreePin(); } @Override public int voltage() { return this.threePinSoket.voltage() * 2; } } 单元测试 class AmericaAdapterSpec extends Specification { def twoPinSoket(){ given: def twoPinSoket = new TwoPinSoketChina() expect: twoPinSoket.chargeWithTwoPin() == \"两孔插座\" twoPinSoket.voltage() == 220 } def threePinSoket(){ given: def threePinSoket = new ThreePinSoketAmerica() expect: threePinSoket.chargeWithThreePin() == \"三孔插座\" threePinSoket.voltage() == 110 } def adapter(){ given: def threePinSoket = new ThreePinSoketAmerica() def twoPinSoket = new AmericaAdapter(threePinSoket) expect: twoPinSoket.chargeWithTwoPin() == \"三孔插座\" twoPinSoket.voltage() == 220 } } "},"content/structural/bridge.html":{"url":"content/structural/bridge.html","title":"2.4、桥接模式","keywords":"","body":"桥接模式 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 JDK中的使用 java.util.logging.Handler java.util.logging.Formatter java.util.Collections#newSetFromMap() jdbc 代码实现 邮件、微信、QQ都可以发送文字、图片、声音消息 当邮件、微信、QQ发送消息时 只有发送消息内容改变 其他不会变 public abstract class Message { protected abstract String getMsg(); } public class Text extends Message { @Override protected String getMsg() { return \"text\"; } } public class Picture extends Message { @Override protected String getMsg() { return \"picture\"; } } public class Voice extends Message { @Override protected String getMsg() { return \"voice\"; } } 消息发送 public abstract class Communicator { Message message; public abstract String send(); public void setMessage(Message message){ this.message = message; } } public class Email extends Communicator { @Override public String send() { return \"email send \" + super.message.getMsg(); } } public class Qicq extends Communicator { @Override public String send() { return \"qicq send \" + super.message.getMsg(); } } public class Wechat extends Communicator { @Override public String send() { return \"wechat send \" + super.message.getMsg(); } } 单元测试 以微信为例 其他两个类似 class WechatSpec extends Specification { @Unroll def \"#result\"() { given: def wechat = new Wechat() wechat.setMessage(message) expect: wechat.send() == result where: message || result new Picture() || \"wechat send picture\" new Text() || \"wechat send text\" new Voice() || \"wechat send voice\" } } "},"content/structural/decorator.html":{"url":"content/structural/decorator.html","title":"2.5、装饰器模式","keywords":"","body":"装饰器模式 装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案 JDK中的使用 java.io.BufferedInputStream#BufferedInputStream(java.io.InputStream) java.io.BufferedOutputStream#BufferedOutputStream(java.io.OutputStream) java.io.DataInputStream#DataInputStream(java.io.InputStream) java.util.Collections.CheckedList java.util.Collections.CheckedSet ava.util.Collections.CheckedMap 代码实现 齐天大圣可以72变 在和杨戬大战中分别变了鸟、鱼、树、寺庙、本身猴子 各个变换之间来回变化 public interface TheGreatestSage { String move(); } public class Monkey implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Monkey() { } public Monkey(TheGreatestSage theGreatestSage) { this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(); if (null != this.theGreatestSage) { sb.append(this.theGreatestSage.move()); sb.append(\" -> \"); } sb.append(\"monkey\"); return sb.toString(); } } public class Bird implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Bird(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"bird\"); return sb.toString(); } } public class Fish implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Fish(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"fish\"); return sb.toString(); } } public class Tree implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Tree(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"tree\"); return sb.toString(); } } public class Temple implements TheGreatestSage { private TheGreatestSage theGreatestSage; public Temple(TheGreatestSage theGreatestSage){ this.theGreatestSage = theGreatestSage; } @Override public String move() { StringBuilder sb = new StringBuilder(this.theGreatestSage.move()); sb.append(\" -> \"); sb.append(\"temple\"); return sb.toString(); } } 单元测试 class TheGreatestSageSpec extends Specification { def theGreatestSage() { expect: theGreatestSage.move() == changeProcess where: theGreatestSage || changeProcess new Monkey() || \"monkey\" new Bird(new Monkey()) || \"monkey -> bird\" new Tree(new Fish(new Monkey())) || \"monkey -> fish -> tree\" new Fish(new Bird(new Temple(new Monkey()))) || \"monkey -> temple -> bird -> fish\" new Temple(new Tree(new Bird(new Fish(new Monkey())))) || \"monkey -> fish -> bird -> tree -> temple\" new Monkey(new Tree(new Temple(new Bird(new Fish(new Monkey()))))) || \"monkey -> fish -> bird -> temple -> tree -> monkey\" } } "},"content/structural/flyweight.html":{"url":"content/structural/flyweight.html","title":"2.6、享元模式","keywords":"","body":"享元模式 享元模式以共享的方式高效地支持大量的细粒度对象，包括内部状态和外部状态。内部状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内部状态并可以共享。外部状态是随环境的改变而改变的、不可以共享的。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外部状态不可以影响享元对象的内部状态，它们是相互独立的。 JDK中的使用 java.lang.Integer#valueOf(int) java.lang.Byte#valueOf(byte) Boolean, Byte, Character, Short, Long, BigDecimal 代码实现 绘制不同颜色的不同图形 将已经绘制过的图形保存起来不用再次绘制 public interface Shape { String draw(Color color); } public class ConcreteShape implements Shape { private String shape; public ConcreteShape(String shape) { this.shape = shape; } @Override public String draw(Color color) { StringBuilder sb = new StringBuilder(); sb.append(\"draw a\"); sb.append(\" \"); sb.append(color.getColor()); sb.append(\" \"); sb.append(this.shape); return sb.toString(); } } public class Color { @Getter private String color; public Color(String color){ this.color = color; } } public class FlyweightFactory { private final Map cache = new ConcurrentHashMap<>(); public Shape create(String shape){ if(!this.cache.containsKey(shape)){ synchronized (this.cache){ if(!this.cache.containsKey(shape)){ this.cache.put(shape, new ConcreteShape(shape)); } } } return this.cache.get(shape); } public int size(){ return this.cache.size(); } } 单元测试 class FlyweightFactorySpec extends Specification { def flyweightInnerState() { given: def factory = new FlyweightFactory() when: def circle = factory.create(\"circle\") def circleCopy = factory.create(\"circle\") then: circle != null circleCopy != null circle == circleCopy circle.is(circleCopy) when: def rectangle = factory.create(\"rectangle\") def rectangleCopy = factory.create(\"rectangle\") then: rectangle != null rectangleCopy != null rectangle == rectangleCopy rectangle.is(rectangleCopy) when: def triangle = factory.create(\"triangle\") def triangleCopy = factory.create(\"triangle\") then: triangle != null triangleCopy != null triangle == triangleCopy triangle.is(triangleCopy) expect: factory.size() == 3 } def flyweightOuterState() { given: def factory = new FlyweightFactory() expect: factory.create(shape).draw(new Color(color)) == draw where: shape | color || draw \"circle\" | \"red\" || \"draw a red circle\" \"rectangle\" | \"yellow\" || \"draw a yellow rectangle\" \"triangle\" | \"black\" || \"draw a black triangle\" \"circle\" | \"black\" || \"draw a black circle\" } } "},"content/structural/proxy.html":{"url":"content/structural/proxy.html","title":"2.7、代理模式","keywords":"","body":"代理模式 代理模式就是多一个代理类出来，替原对象进行一些操作。代理模式分为两种，静态代理和动态代理 静态代理：由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 动态代理：动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。 代码实现 学生、白领通过中介租房 public interface Renting{ String rent(); } public class Student implements Renting { @Override public String rent() { return \"student rent\"; } public String name(){ return \"student\"; } } public class WhiteCollarWorker implements Renting { @Override public String rent() { return \"white collar worker rent\"; } } 静态代理 运行之前代理类和委托类关系就已经确定 public class Realtor implements Renting { private Renting renting; public Realtor(Renting renting){ this.renting = renting; } @Override public String rent() { return \"realtor in the name of \" + this.renting.rent(); } } 动态代理 动态代理分为jdk动态代理和cglib动态代理 jdk动态代理通过反射类Proxy和InvocationHandler回调接口实现，要求委托类必须实现一个接口，只能对该类接口中定义的方法实现代理，这在实际编程中有一定的局限性。 cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 public class JdkProxy implements InvocationHandler { private Object target; public JdkProxy(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { return method.invoke(this.target, args); } public Object getProxyInstance() { return Proxy.newProxyInstance( this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this ); } } public class CglibProxy implements MethodInterceptor { private Object target; public CglibProxy(Object target){ this.target = target; } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { return methodProxy.invokeSuper(o, objects); } public Object getProxyInstance() { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); enhancer.setCallback(this); return enhancer.create(); } } 单元测试 静态代理 class RealtorSpec extends Specification { def renting() { expect: renting.rent() == result where: renting || result new Student() || \"student rent\" new WhiteCollarWorker() || \"white collar worker rent\" } def realtor() { expect: realtor.rent() == result where: realtor || result new Realtor(new Student()) || \"realtor in the name of student rent\" new Realtor(new WhiteCollarWorker()) || \"realtor in the name of white collar worker rent\" } } 动态代理 class JdkProxySpec extends Specification { def jdkProxyInterface() { given: def jdkProxy = new JdkProxy(target) def instance = (Renting) jdkProxy.getProxyInstance() expect: instance.rent() == result where: target || result new Student() || \"student rent\" new WhiteCollarWorker() || \"white collar worker rent\" } def jdkProxyClass(){ given: def jdkProxy = new JdkProxy(new Student()) when: // 代理类不能被强转为Student def studentProxy = (Student) jdkProxy.getProxyInstance() then: thrown(Exception.class) studentProxy == null } } class CglibProxySpec extends Specification { def cglibProxyInterface(){ given: def cglibProxy = new CglibProxy(target) def instance = (Renting) cglibProxy.getProxyInstance() expect: instance.rent() == result where: target || result new Student() || \"student rent\" new WhiteCollarWorker() || \"white collar worker rent\" } def cglibProxyClass(){ given: def cglibProxy = new CglibProxy(new Student()) // 和jdk动态代理主要区别 // jdk 获得实例返回的是接口 // cglib 获得实例返回的是类 def instance = (Student) cglibProxy.getProxyInstance() expect: instance.rent() == \"student rent\" instance.name() == \"student\" } } "},"content/behavioural/":{"url":"content/behavioural/","title":"3、行为型模式","keywords":"","body":"行为型模式 行为模式是对在不同的对象之间划分责任和算法的抽象化。行为模式不仅仅是关于类和对象的，而且是关于它们之间相互作用的。 类的行为模式 类的行为模式使用继承关系在几个类之间分配行为。 对象的行为模式 对象的行为模式是使用对象聚合类分配行为的。 行为型模式包括：责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模版方法、访问者共11中模式。 "},"content/behavioural/chain_of_responsibility.html":{"url":"content/behavioural/chain_of_responsibility.html","title":"3.1、责任链模式","keywords":"","body":"责任链模式 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 JDK中的使用 java.util.logging.Logger#log(java.util.logging.LogRecord) javax.servlet.Filter#doFilter() dubbo、motan中的filter链 代码实现 在公司申请经费在一定金额限制下分别可以由leader、manager、boss同意 // 申请请求 @Data public class HandleRequest { /** * 活动主体 */ private String activityTheme; /** * 申请活动资金 */ private BigDecimal activityCapital; } // 申请结果 @Data @Builder public class HandleResult { private Boolean isOk; private String from; private String result; public static HandleResult ok(String from, String result){ return HandleResult.builder() .isOk(Boolean.TRUE) .from(from) .result(result) .build(); } public static HandleResult reject(String from, String result){ return HandleResult.builder() .isOk(Boolean.FALSE) .from(from) .result(result) .build(); } } public interface Handler { HandleResult handle(HandleRequest request); } public abstract class AbstractHandler implements Handler { @Getter private Handler superior; public AbstractHandler() { } public AbstractHandler(Handler superior) { this.superior = superior; } /** * 职位名称 * @return 职位名称 */ protected abstract String getPosition(); /** * 当前是否能审批 * @param request 请求 * @return true/能 false/不能 */ protected abstract boolean canApprove(HandleRequest request); @Override public HandleResult handle(HandleRequest request) { if (this.canApprove(request)) { return HandleResult.ok(this.getPosition(), request.getActivityTheme() + \" ok\"); } return this.superior != null ? this.superior.handle(request) : HandleResult.reject(this.getPosition(), request.getActivityTheme() + \" reject\"); } } public class Leader extends AbstractHandler { public Leader(){ super(); } public Leader(Handler handler){ super(handler); } @Override protected String getPosition() { return \"leader\"; } @Override protected boolean canApprove(HandleRequest request) { // leader只能审批100元及以下的金额 return request.getActivityCapital().compareTo(new BigDecimal(\"100\")) 单元测试 class AbstractHandlerSpec extends Specification { def leader() { given: def leader = new Leader() def handleResult = leader.handle(new HandleRequest(activityTheme: activityTheme, activityCapital: activityCapital)) expect: handleResult.getIsOk() == isOk handleResult.getFrom() == fromPosition handleResult.getResult() == resultMessage where: activityCapital | activityTheme || fromPosition || resultMessage || isOk new BigDecimal(\"100\") | \"团建\" || \"leader\" || \"团建 ok\" || Boolean.TRUE new BigDecimal(\"101\") | \"ktv\" || \"leader\" || \"ktv reject\" || Boolean.FALSE } def manager() { given: def manager = new Manager() def leader = new Leader(manager) def handleResult = leader.handle(new HandleRequest(activityTheme: activityTheme, activityCapital: activityCapital)) expect: handleResult.getIsOk() == isOk handleResult.getFrom() == fromPosition handleResult.getResult() == resultMessage where: activityCapital | activityTheme || fromPosition || resultMessage || isOk new BigDecimal(\"100\") | \"团建\" || \"leader\" || \"团建 ok\" || Boolean.TRUE new BigDecimal(\"101\") | \"ktv\" || \"manager\" || \"ktv ok\" || Boolean.TRUE new BigDecimal(\"499\") | \"乒乓球\" || \"manager\" || \"乒乓球 ok\" || Boolean.TRUE new BigDecimal(\"501\") | \"室内篮球\" || \"manager\" || \"室内篮球 reject\" || Boolean.FALSE } def boss() { given: def boss = new Boss() def manager = new Manager(boss) def leader = new Leader(manager) def handleResult = leader.handle(new HandleRequest(activityTheme: activityTheme, activityCapital: activityCapital)) expect: handleResult.getIsOk() == isOk handleResult.getFrom() == fromPosition handleResult.getResult() == resultMessage where: activityCapital | activityTheme || fromPosition || resultMessage || isOk new BigDecimal(\"100\") | \"团建\" || \"leader\" || \"团建 ok\" || Boolean.TRUE new BigDecimal(\"101\") | \"ktv\" || \"manager\" || \"ktv ok\" || Boolean.TRUE new BigDecimal(\"499\") | \"乒乓球\" || \"manager\" || \"乒乓球 ok\" || Boolean.TRUE new BigDecimal(\"501\") | \"室内篮球\" || \"boss\" || \"室内篮球 ok\" || Boolean.TRUE new BigDecimal(\"1000\") | \"旅游\" || \"boss\" || \"旅游 ok\" || Boolean.TRUE new BigDecimal(\"1001\") | \"显卡\" || \"boss\" || \"显卡 reject\" || Boolean.FALSE } } "},"content/behavioural/command.html":{"url":"content/behavioural/command.html","title":"3.2、命令模式","keywords":"","body":"命令模式 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 JDK中的使用 java.util.concurrent.ExecutorService#execute(java.lang.Runnable) java.util.concurrent.ExecutorService#submit(java.util.concurrent.Callable) 代码实现 遥控器可以控制电视开、关、声音加减、频道变换 @FunctionalInterface public interface Command { T execute(); } @Getter @Setter(AccessLevel.PROTECTED) public class Television { /** * 电视名称 */ private String name; /** * 当前所在频道 */ private Integer channel; /** * 当前音量 */ private Integer volume; public Television(){ this(\"HaierTv\"); } public Television(String name){ this(name, 10, 20); } public Television(String name, Integer channel, Integer volume){ this.name = name; this.channel = channel; this.volume = volume; } /** * 电视机执行遥控器命令 * @param command 具体命令 * @param 命令返回值 * @return 命令执行结果 */ public T execute(Command command){ return command.execute(); } } public class RemoteControl { private Television television; @Setter private Command turnOn = () -> this.television.getName() + \" on!\"; @Setter private Command turnOff = () -> this.television.getName() + \" off!\"; @Setter private Command volumeUp = () -> { int currentVolume = this.television.getVolume(); this.television.setVolume(++currentVolume); return currentVolume volumeDown = () -> { int currentVolume = this.television.getVolume(); this.television.setVolume(--currentVolume); return currentVolume >= 0 ? currentVolume : 0; }; @Setter private Command channelUp = () -> { int currentChannel = this.television.getChannel(); this.television.setChannel(++currentChannel); return currentChannel channelDown = () -> { int currentChannel = this.television.getChannel(); this.television.setChannel(--currentChannel); return currentChannel > 0 ? currentChannel : 1; }; public RemoteControl(Television television) { this.television = television; } public String turnOn() { return this.television.execute(turnOn); } public String turnOff() { return this.television.execute(turnOff); } public Integer volumeUp() { return this.television.execute(volumeUp); } public Integer volumeDown() { return this.television.execute(volumeDown); } public Integer channelUp() { return this.television.execute(channelUp); } public Integer channelDown() { return this.television.execute(channelDown); } } 单元测试 class CommandSpec extends Specification { def control() { given: def tv = new Television(\"佳能电视\") def control = new RemoteControl(tv) when: def on = control.turnOn() then: on == tv.getName() + \" on!\" when: def volumeUp = control.volumeUp() then: volumeUp == tv.getVolume() when: def volumeDown = control.volumeDown() then: volumeDown == tv.getVolume() when: def channelUp = control.channelUp() then: channelUp == tv.getChannel() when: def channelDown = control.channelDown() then: channelDown == tv.getChannel() when: def off = control.turnOff() then: off == tv.getName() + \" off!\" } def command(){ given: def tv = new Television() def control = new RemoteControl(tv) def onMsg = \"金光闪闪的打开!\" def offMsg = \"牛逼哄哄的关掉!\" control.setTurnOn({ return tv.getName() + onMsg }) control.setTurnOff({ return tv.getName() + offMsg }) when: def on = control.turnOn() then: on == tv.getName() + onMsg when: def off = control.turnOff() then: off == tv.getName() + offMsg } } "},"content/behavioural/interpreter.html":{"url":"content/behavioural/interpreter.html","title":"3.3、解释器模式","keywords":"","body":"解释器模式 给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。 JDK中的使用 java.util.regex.Pattern#matcher(java.lang.CharSequence) java.text.MessageFormat#format(java.lang.String, java.lang.Object...) java.lang.String#format(java.lang.String, java.lang.Object...) 代码实现 输入一个计算表达式 计算出结果 代码不完整仅表达解释器这个意思 // 计算结果 @Data @Builder public class CalculateResult { private boolean isValid; private BigDecimal result; public static CalculateResult invalid() { return CalculateResult.builder() .isValid(false) .build(); } public static CalculateResult valid(BigDecimal result) { return CalculateResult.builder() .isValid(true) .result(result) .build(); } } // 计算器帮助类 final class CalculateHelper { private static final String LEFT_BRACKET = \"(\"; private static final String RIGHT_BRACKET = \")\"; private static final String PLUS = \"+\"; private static final String MINUS = \"-\"; private static final String MULTIPLY = \"*\"; private static final String DIVIDE = \"/\"; private static final String REMAINDER = \"%\"; private static final String POINT = \".\"; private CalculateHelper() { } static BigDecimal calculate(String expression) { Stack order = convertInOrder2PostOrder(expression); return calc(order); } /** * * 首先维护的是两个栈，我们这里暂且称为S1和S2，S1中的结果最后存的就是逆波兰表达式， * S2中将用于暂时存放运算符并且在最终形成逆波兰表达式的时候，该栈是会清空的。 * * * * 如果遇到的是数字，我们直接加入到栈S1中； * * * 如果遇到的是左括号，则直接将该左括号加入到栈S2中； * * * 如果遇到的是右括号，那么将栈S2中的运算符一次出栈加入到栈S1中，直到遇到左括号， * 但是该左括号出栈S2并不加入到栈S1中； * * * 如果遇到的是运算符，包括单目运算符和双目运算符，我们按照下面的规则进行操作： * * * 如果此时栈S2为空，则直接将运算符加入到栈S2中； * * * 如果此时栈S2不为空，当前遍历的运算符的优先级大于等于栈顶运算符的优先级，那么直接入栈S2； * * * 如果此时栈S2不为空，当前遍历的运算符的优先级小于栈顶运算符的优先级，则将栈顶运算符一直出栈加入到栈S1中， * 直到栈为空或者遇到一个运算符的优先级小于等于当前遍历的运算符的优先级 此时将该运算符加入到栈S2中； * * * * * 直到遍历完整个中序表达式之后，栈S2中仍然存在运算符，那么将这些运算符依次出栈加入到栈S1中，直到栈为空。 * * * @param expression 算式字符串 */ private static Stack convertInOrder2PostOrder(String expression) { Stack order = new Stack<>(); Stack temp = new Stack<>(); for (int i = 0, len = expression.length(); i 0) { String top = temp.pop(); if (LEFT_BRACKET.equals(top)) { break; } order.push(top); } } else { // + - * / % if (temp.isEmpty()) { temp.push(word); } else { String top = temp.peek(); if (compareTo(word, top) >= 0) { temp.push(word); } else { while (temp.size() > 0) { top = temp.peek(); if (compareTo(word, top) * 我们此时维护一个数据结果栈S3，我们将会看到该栈中最后存放的是最终的表达式的值。 * 我们从左至右的遍历栈S1，然后按照下面的规则进行操作栈S3. * * * * 如果遇到的是数字，那么直接将数字压入到S3中 * * * 如果遇到的是单目运算符，那么取S3栈顶的一个元素进行单目运算之后，将结果再次压入到栈S3中； * * * 如果遇到的是双目运算符，那么取S3栈顶的两个元素进行，首先出栈的在左，后出栈的在右进行双目运算符的计算，将结果再次压入到S3中。 * * * @param order * @return */ private static BigDecimal calc(Stack order) { LinkedList copyOrder = new LinkedList<>(order); Stack temp = new Stack<>(); while (copyOrder.size() > 0) { String top = copyOrder.pollFirst(); if (isOperator(top)) { String second = temp.pop(); String first = temp.pop(); temp.push(calc(first, second, top).toString()); } else { temp.push(top); } } return new BigDecimal(temp.pop()); } private static BigDecimal calc(String first, String second, String operator) { BigDecimal a = new BigDecimal(first); BigDecimal b = new BigDecimal(second); if(PLUS.equals(operator)){ return a.add(b); }else if(MINUS.equals(operator)){ return a.subtract(b); }else if(MULTIPLY.equals(operator)){ return a.multiply(b); }else if(DIVIDE.equals(operator)){ return a.divide(b); }else if(REMAINDER.equals(operator)){ return a.remainder(b); } return null; } /** * 是否是数字和小数点 * @param word 长度为1的字符串 * @return true/false */ private static boolean isDigit(String word) { char c = word.toCharArray()[0]; return POINT.equals(\"\" + c) || Character.isDigit(c); } /** * 是否是运算符(+ - * / %) * @param word 长度为1的字符串 * @return true/false */ private static boolean isOperator(String word) { return PLUS.equals(word) || MINUS.equals(word) || MULTIPLY.equals(word) || DIVIDE.equals(word) || REMAINDER.equals(word); } /** * 比较操作符优先级 * @param operator1 运算符1 * @param operator2 运算符2 * @return >0运算符1优先级大于运算符2 0优先级相同 单元测试 class CalculatorSpec extends Specification { def calculate() { given: def calculator = new Calculator(expression) def result = calculator.calculate() expect: result.isValid() == isValid result.getResult() == calculateResult where: expression || isValid || calculateResult \"a\" || false || null \"1+++1\" || false || null \"-1+1\" || false || null \"--1+1\" || false || null \"1+1\" || true || 2 \"1+(1-1)\" || true || 1 \"12.232+((111+333.222)-2*5)\" || true || 446.454 } } "},"content/behavioural/iterator.html":{"url":"content/behavioural/iterator.html","title":"3.4、迭代器模式","keywords":"","body":"迭代器模式 迭代器模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation） JDK中的使用 java.util.Iterator java.util.Enumeration 代码实现 实现一个List的迭代器 class MyIterator implements Iterator { private LinkedList list; private int index; MyIterator(LinkedList list) { this.list = list; this.index = 0; } @Override public boolean hasNext() { return this.index extends LinkedList implements Iterable { @Override public Iterator iterator() { return new MyIterator<>(this); } } 单元测试 class MyListSpec extends Specification { def myList(){ def data given: def list = new MyList() list.add(\"hello\") list.add(\"world\") list.add(\"!\") def iterator = list.iterator() expect: iterator != null iterator.hasNext() when: data = iterator.next() then: data == \"hello\" iterator.hasNext() when: data = iterator.next() then: data == \"world\" iterator.hasNext() when: data = iterator.next() then: data == \"!\" !iterator.hasNext() } } "},"content/behavioural/mediator.html":{"url":"content/behavioural/mediator.html","title":"3.5、中介者模式","keywords":"","body":"中介者模式 用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。 JDK中的使用 java.util.Timer#schedule(java.util.TimerTask, java.util.Date) java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object...) java.util.concurrent.ExecutorService#submit(java.util.concurrent.Callable) 代码实现 ATM作为中介者 让银行和客户交互 以取存款为例 // 虚拟出纳 public interface Teller { /** * 取钱操作 * @param account 卡号 * @param amount 金额 */ void withdraw(String account, BigDecimal amount); /** * 存钱操作 * @param account 卡号 * @param amount 金额 */ void deposit(String account, BigDecimal amount); } public class Bank implements Teller { @Getter private BigDecimal balance; public Bank(BigDecimal balance) { this.balance = balance; } @Override public void withdraw(String account, BigDecimal amount) { // 客户取钱 银行余额减少 this.balance = this.balance.subtract(amount); } @Override public void deposit(String account, BigDecimal amount) { // 客户存钱 银行余额增加 this.balance = this.balance.add(amount); } } public class Customer implements Teller { @Getter private BigDecimal cash; public Customer(BigDecimal cash) { this.cash = cash; } @Override public void withdraw(String account, BigDecimal amount) { // Atm取钱 客户现金增加 this.cash = this.cash.add(amount); } @Override public void deposit(String account, BigDecimal amount) { // Atm存钱 客户现金减少 this.cash = this.cash.subtract(amount); } } public class Atm implements Teller { private Bank bank; private Customer customer; public Atm(Bank bank, Customer customer) { this.bank = bank; this.customer = customer; } @Override public void withdraw(String account, BigDecimal amount) { this.bank.withdraw(account, amount); this.customer.withdraw(account, amount); } @Override public void deposit(String account, BigDecimal amount) { this.bank.deposit(account, amount); this.customer.deposit(account, amount); } } 单元测试 class AtmSpec extends Specification { def atm(){ given: def bank = new Bank(new BigDecimal(\"1000\")) def customer1 = new Customer(new BigDecimal(\"250\")) def customer2 = new Customer(new BigDecimal(\"200\")) when: def atm1 = new Atm(bank, customer1) atm1.deposit(\"1234\", new BigDecimal(\"100\")) then: customer1.getCash() == new BigDecimal(\"150\") bank.getBalance() == new BigDecimal(\"1100\") when: atm1.withdraw(\"1234\", new BigDecimal(\"50\")) then: customer1.getCash() == new BigDecimal(\"200\") bank.getBalance() == new BigDecimal(\"1050\") when: def atm2 = new Atm(bank, customer2) atm2.withdraw(\"4321\", new BigDecimal(\"20\")) then: customer2.getCash() == new BigDecimal(\"220\") bank.getBalance() == new BigDecimal(\"1030\") when: atm2.deposit(\"4321\", new BigDecimal(\"70\")) then: customer2.getCash() == new BigDecimal(\"150\") bank.getBalance() == new BigDecimal(\"1100\") } } "},"content/behavioural/memento.html":{"url":"content/behavioural/memento.html","title":"3.6、备忘录模式","keywords":"","body":"备忘录模式 备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是一个用来存储另外一个对象内部状态的快照的对象，备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。 JDK中的使用 java.util.Date Date对象通过自身内部的一个long值来实现备忘录模式 所有实现java.io.Serializable接口的类 代码实现 一个jar包的groupId、artifactId、version在使用的时候备份 可以随时还原到上一个版本 public interface Undoable { /** * 保存快照 */ void save(); /** * 还原到最近一次快照 */ void undo(); } @Data @ToString(exclude = \"snapshot\") public class Jar implements Undoable { private String groupId; private String artifactId; private String version; /** * 备份的快照 */ @Setter(AccessLevel.PRIVATE) @Getter(AccessLevel.PRIVATE) private Jar snapshot; @Override public void save() { if(null == this.snapshot){ this.snapshot = new Jar(); } this.snapshot.setGroupId(this.getGroupId()); this.snapshot.setArtifactId(this.getArtifactId()); this.snapshot.setVersion(this.getVersion()); } @Override public void undo() { if (null != this.snapshot) { this.setGroupId(this.snapshot.getGroupId()); this.setArtifactId(this.snapshot.getArtifactId()); this.setVersion(this.snapshot.getVersion()); } } } 单元测试 class JarSpec extends Specification { def jar(){ given: def jar = new Jar(groupId: \"com.gome\", artifactId: \"pattern\", version: \"1.0.0\") jar.save() jar.setVersion(\"1.0.1\") expect: jar != null jar.groupId == \"com.gome\" jar.artifactId == \"pattern\" jar.version == \"1.0.1\" when: jar.undo() then: jar.groupId == \"com.gome\" jar.artifactId == \"pattern\" jar.version == \"1.0.0\" when: jar.setGroupId(\"org.apache\") jar.save() jar.setGroupId(\"com.gome\") jar.setVersion(\"1.2.1\") jar.undo() then: jar.groupId == \"org.apache\" jar.artifactId == \"pattern\" jar.version == \"1.0.0\" } } "},"content/behavioural/observer.html":{"url":"content/behavioural/observer.html","title":"3.7、观察者模式","keywords":"","body":"观察者模式 观察者模式又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 JDK中的使用 java.util.Observer java.util.Observable 代码实现 水果店员没卖出一个订单的水果 老板会关心每种水果卖出了多少 老板娘会关心一共卖出了多少钱 @Getter public enum Fruit { APPLE(\"苹果\", new BigDecimal(\"2\")), ORANGE(\"桔子\", new BigDecimal(\"1.5\")), GRAPE(\"葡萄\", new BigDecimal(\"3\")), PLUM(\"李子\", new BigDecimal(\"6.5\")); private String name; private BigDecimal unitPrice; Fruit(String name, BigDecimal unitPrice){ this.name = name; this.unitPrice = unitPrice; } } @Data @AllArgsConstructor public class Order { private Fruit type; private BigDecimal weight; } public class FruitStoreAssistant extends Observable { public FruitStoreAssistant(Observer ...observers){ super(); if(observers != null && observers.length > 0){ for(Observer observer : observers){ super.addObserver(observer); } } } /** * 贩卖水果 * @param order 水果订单 */ public void sell(Order order){ super.setChanged(); super.notifyObservers(order); } } @Getter public class FruitsStoreBoss implements Observer { private Map statistics = new HashMap<>(); private BigDecimal total = new BigDecimal(\"0\"); public FruitsStoreBoss(){ Fruit []fruits = Fruit.values(); for(Fruit fruit : fruits){ statistics.put(fruit, new BigDecimal(\"0\")); } } @Override public void update(Observable o, Object arg) { if(arg instanceof Order){ this.account((Order) arg); } } private void account(Order order){ Fruit fruit = order.getType(); BigDecimal current = this.statistics.get(fruit); this.statistics.put(fruit, current.add(order.getWeight())); this.total = this.total.add(order.getWeight()); } } @Getter public class FruitsStoreLandlady implements Observer { private Map statistics = new HashMap<>(); private BigDecimal total = new BigDecimal(\"0\"); public FruitsStoreLandlady(){ Fruit []fruits = Fruit.values(); for(Fruit fruit : fruits){ statistics.put(fruit, new BigDecimal(\"0\")); } } @Override public void update(Observable o, Object arg) { if(arg instanceof Order){ this.account((Order) arg); } } private void account(Order order){ Fruit fruit = order.getType(); BigDecimal current = this.statistics.get(fruit); BigDecimal orderTotal = fruit.getUnitPrice().multiply(order.getWeight()); this.statistics.put(fruit, current.add(orderTotal)); this.total = this.total.add(orderTotal); } } 单元测试 class FruitStoreSpec extends Specification { def fruitStoreEach() { given: def boss = new FruitsStoreBoss() def landlady = new FruitsStoreLandlady() def assistant = new FruitStoreAssistant(boss, landlady) when: assistant.sell(new Order(fruit, weight)) then: landlady.getTotal() == totalAmount boss.getTotal() == totalWeight where: fruit | weight || totalAmount || totalWeight Fruit.PLUM | 8.7 || Fruit.PLUM.unitPrice * 8.7 || 8.7 Fruit.APPLE | 1 || Fruit.APPLE.unitPrice * 1 || 1 Fruit.GRAPE | 2.3 || Fruit.GRAPE.unitPrice * 2.3 || 2.3 Fruit.ORANGE | 2.5 || Fruit.ORANGE.unitPrice * 2.5 || 2.5 } } "},"content/behavioural/state.html":{"url":"content/behavioural/state.html","title":"3.8、状态模式","keywords":"","body":"状态模式 将主对象和其状态分离，状态对象负责主对象的状态转换，使主对象类功能减轻 JDK中的使用 未发现 代码实现 程序员在不同时间编码可能有不同状态 比如上午10点很愉快的编码 下午4点确实昏昏欲睡的编码 interface State { String FORENOON_STATE = \"%s点正在努力编码!\"; String NOON_STATE = \"%s点正在吃饭!\"; String AFTERNOON_STATE = \"%s点疲劳的编码!\"; String EVENING_STATE = \"%s点疲惫的加班编码!\"; String NIGHT_STATE = \"%s点正在睡觉!\"; String OFF_DUTY_STATE = \"%s点愉快下班!\"; String coding(Task task); } public class ForenoonState implements State { @Override public String coding(Task task) { if(task.getTime() = 12 && task.getTime() 13 && task.getTime() = 18 && task.getTime() 单元测试 class StateSpec extends Specification { def task() { given: def task = new Task(time, isDone) expect: task.coding() == state where: time | isDone || state 1 | false || String.format(NIGHT_STATE, 1) 10 | false || String.format(FORENOON_STATE, 10) 12 | false || String.format(NOON_STATE, 12) 13 | true || String.format(OFF_DUTY_STATE, 13) 14 | false || String.format(AFTERNOON_STATE, 14) 19 | false || String.format(EVENING_STATE, 19) 20 | true || String.format(OFF_DUTY_STATE, 20) 23 | false || String.format(NIGHT_STATE, 23) 23 | true || String.format(OFF_DUTY_STATE, 23) } } "},"content/behavioural/strategy.html":{"url":"content/behavioural/strategy.html","title":"3.9、策略模式","keywords":"","body":"策略模式 每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 JDK中的使用 java.util.Comparator java.util.concurrent.RejectedExecutionHandler java.io.FilenameFilter java.io.FileFilter 代码实现 在超时购买商品在不同时期有不同的优惠策略 比如正常策略、促销策略、临期策略等 public class Order { private BigDecimal amount; public Order(BigDecimal amount){ this.amount = amount; } public BigDecimal check(DiscountPolicy policy){ return policy.discount(this.amount); } } @FunctionalInterface public interface DiscountPolicy { BigDecimal discount(BigDecimal amount); } public class NormalPolicy implements DiscountPolicy { @Override public BigDecimal discount(BigDecimal amount) { return amount; } } public class PromotioPolicy implements DiscountPolicy { @Override public BigDecimal discount(BigDecimal amount) { // 促销9折 return amount.multiply(new BigDecimal(\"0.9\")); } } public class DeadlinePolicy implements DiscountPolicy { @Override public BigDecimal discount(BigDecimal amount) { // 临期6折 return amount.multiply(new BigDecimal(\"0.6\")); } } 单元测试 class OrderSpec extends Specification { @Shared def selfPolicy = { BigDecimal it -> return it * (new BigDecimal(\"0.1\")) } def order() { given: def order = new Order(new BigDecimal(\"100\")) expect: order.check(policy) == amount where: policy || amount new NormalPolicy() || 100 new PromotioPolicy() || 90 new DeadlinePolicy() || 60 // 自定义闭包策略 selfPolicy || 10 } } "},"content/behavioural/template_method.html":{"url":"content/behavioural/template_method.html","title":"3.10、模版方法模式","keywords":"","body":"模版方法模式 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。 JDK中的使用 java.util.AbstractCollection#iterator() java.util.AbstractCollection#size() java.util.Collections#sort(java.util.List, java.util.Comparator) java.io.InputStream#read() spring service事务拦截 service就是模板方法 代码实现 手动档汽车和自动档汽车起步的步骤 手动档钥匙点火->挂1挡->起步 自动档按钮点火->挂D挡->起步 public interface Car { String drive(); } public abstract class AbstractCar implements Car { @Override public String drive() { StringBuilder sb = new StringBuilder(); sb.append(this.ignite()); sb.append(\" -> \"); sb.append(this.shift()); sb.append(\" -> \"); sb.append(this.advance()); return sb.toString(); } /** * 点火 * @return */ protected abstract String ignite(); /** * 挂挡 * @return */ protected abstract String shift(); /** * 前进 * @return */ protected String advance(){ return \"前进\"; } } public class ManualGearshiftCar extends AbstractCar { @Override protected String ignite() { return \"钥匙点火\"; } @Override protected String shift() { return \"挂1挡\"; } } public class AutomaticGearshiftCar extends AbstractCar { @Override protected String ignite() { return \"按钮点火\"; } @Override protected String shift() { return \"挂D挡\"; } } 单元测试 class CarSpec extends Specification { def car() { given: def Car myCar = car expect: myCar.drive() == result where: car || result new ManualGearshiftCar() || \"钥匙点火 -> 挂1挡 -> 前进\" new AutomaticGearshiftCar() || \"按钮点火 -> 挂D挡 -> 前进\" } } "},"content/behavioural/visitor.html":{"url":"content/behavioural/visitor.html","title":"3.11、访问者模式","keywords":"","body":"访问者模式 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。 JDK中的使用 访问者一般成对出现 即访问者和被访问者 java.util.function.Consumer java.util.List#forEach(java.util.function.Consumer) java.util.function.BiConsumer java.util.Map#forEach(java.util.function.BiConsumer) java.util.function.BiFunction java.util.Map#replaceAll(java.util.function.BiFunction) javax.lang.model.element.AnnotationValue javax.lang.model.element.AnnotationValueVisitor javax.lang.model.element.Element javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror javax.lang.model.type.TypeVisitor 代码实现 @Data public class Order { /** * 周几 1~7 周一~周日 */ private int dayOfWeek; /** * 金额 */ private BigDecimal amount; } @FunctionalInterface public interface Visitable { void accept(T t); } // MyList见迭代器模式 public class VisitableList extends MyList{ /** * 类似forEach 实现自己的访问者 * @param visitable 访问者 */ public void visitEach(Visitable visitable) { for(T t : this){ visitable.accept(t); } } } 单元测试 class VisitableListSpec extends Specification { def visit() { given: // 记录原始数据 def book = new HashMap() book.put(1, new Order(dayOfWeek: 1, amount: 6)) book.put(2, new Order(dayOfWeek: 2, amount: 12)) book.put(5, new Order(dayOfWeek: 5, amount: 7)) book.put(6, new Order(dayOfWeek: 6, amount: 11)) book.put(7, new Order(dayOfWeek: 7, amount: 8)) // 复制数据 def list = new VisitableList() book.each { key, value -> list.add(new Order(dayOfWeek: value.getDayOfWeek(), amount: value.getAmount())) } when: // 工作日 统一总价打八折 // 使用闭包/lambda实现Visitable接口 list.visitEach({ t -> if (t.getDayOfWeek() def day = it.getDayOfWeek() if(day if (t.getDayOfWeek() > 5 && t.getAmount() >= 10) { t.setAmount(t.getAmount() * 0.9) } }) then: // 依次遍历list 确保数据一致 list.every { it -> def day = it.getDayOfWeek() if(day 5 && book.get(day).getAmount() >= 10){ it.getAmount() == book.get(day).getAmount() * 0.9 }else{ it.getAmount() == book.get(day).getAmount() } } } } "}}